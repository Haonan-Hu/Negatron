#include <ostream>
#include <string>
#include "3ac.hpp"
#include "err.hpp"

namespace lake{

void IRProgram::allocGlobals(std::ostream& out){
	// TODO(Implement me)
	std::string n;
	out<<"\n.data\n";
	for(auto l : globals){
		// i++;
		// int t = 16 + 8*i;
		// k = "-" + std::to_string(t) + "(%rbp)";
		n = "glbl_" + l.first->getName();
		out<<n<<":\n"; // glbl_name
		out<<"\t.quad 0\n";
		l.second->setMemoryLoc(n);
	}

	for(auto s : strings){
		out<<s.first->getName()<<":\n"; // glbl_name
		out<<"\t.asciz "<<s.second<<"\n";
		s.first->setMemoryLoc(s.first->getName());
	}
	if(strings.size() != 0){
		out<<".align 8\n";
	}
}

void IRProgram::datagenX64(std::ostream& out){
	// TODO(Implement me)
	out<<".text\n";
}

void IRProgram::toX64(std::ostream& out){
	// TODO(Implement me)
	datagenX64(out);
	allocGlobals(out);
	out<<"\n.globl fun_main\n";
	for (auto p : procs){
		p->toX64(out);
	}
}

void Procedure::allocLocals(){
	int i = 0;
	std::string k = "";
	for(auto l : locals){
		i++;
		int t = 16 + 8*i;
		k = "-" + std::to_string(t) + "(%rbp)";
		l.second->setMemoryLoc(k);
	}
	size_t j = 0;
	for(auto f : formals){
		j++;
		size_t t = (formals.size()-j)*8;
		k = std::to_string(t) + "(%rbp)";
		f->setMemoryLoc(k);
	}
}

void Procedure::toX64(std::ostream& out){
	//Allocate all locals
	allocLocals();
	bool temp = false;
	out << "\nfun_" << myName << ":" << "\n";

	enter->codegenX64(out);
	size_t nl = numLocals();
	size_t subSize = 8 * nl;
	if(nl != 0)
		out<<"\tsubq $"<<subSize<<", %rsp\n";

	for (auto quad : bodyQuads){
		quad->codegenLabels(out);
		quad->codegenX64(out);
	}
	leave->codegenLabels(out);
	if(nl != 0)
		out<<"\taddq $"<<subSize<<", %rsp\n";
	else{
		out<<"\n";
	}
	leave->codegenX64(out);

	if(myName == "main"){
		if(nl == 0)
			out<<"\n";
		out<<"\tmovq (%rsp), %rbp\n";
		out<<"\taddq $8, %rsp\n";
		out<<"\tret\n";
	}
}

void Quad::codegenLabels(std::ostream& out){
	if (labels.empty()){ return; }

	size_t numLabels = labels.size();
	size_t labelIdx = 0;
	for ( Label * label : labels){
		out << label->toString() << ": ";
		if (labelIdx != numLabels - 1){ out << "\n"; }
		labelIdx++;
	}
}

void BinOpQuad::codegenX64(std::ostream& out){
	// TODO(Implement me)
	if(op == ADD){
		src1->genLoad(out, "%rax");
		src2->genLoad(out, "%rbx");
		out<<"\taddq %rbx, %rax\n";
		// dst->genStore(out,"%rax");
	}
	else if(op == SUB) {
		src1->genLoad(out, "%rax");
		src2->genLoad(out, "%rbx");
		out<<"\tsubq %rbx, %rax\n";
		// out<<"\tmovq %rbx, %rax\n";
	}
	else if(op == DIV) {
		src1->genLoad(out, "%rax");
		src2->genLoad(out, "%rbx");
		out<<"\tidivq %rbx\n";
	}
	else if(op == MULT) {
		src1->genLoad(out, "%rax");
		src2->genLoad(out, "%rbx");
		out<<"\timulq %rbx, %rax\n";
	}
	else if(op == OR) {
		src1->genLoad(out, "%rbx");
		src2->genLoad(out, "%rax");
		out<<"\torq %rbx, %rax\n";
	}
	else if(op == AND) {
		src1->genLoad(out, "%rax");
		src2->genLoad(out, "%rbx");
		out<<"\tandq %rbx, %rax\n";
	}
	else if(op == EQ){
		src1->genLoad(out, "%rax");
		src2->genLoad(out, "%rbx");
		out<<"\tcmpq %rbx, %rax\n";
		out<<"\tmovq $0, %rax\n";
		out<<"\tsete %al\n";
	}
	else if(op == NEQ){
		src1->genLoad(out, "%rax");
		src2->genLoad(out, "%rbx");
		out<<"\tcmpq %rbx, %rax\n";
		out<<"\tmovq $0, %rax\n";
		out<<"\tsetne %al\n";
	}
	else if(op == LT) {
		src1->genLoad(out, "%rax");
		src2->genLoad(out, "%rbx");
		out<<"\tcmpq %rbx, %rax\n";
		out<<"\tmovq $0, %rax\n";
		out<<"\tsetl %al\n";
	}
	else if(op == GT) {
		src1->genLoad(out, "%rax");
		src2->genLoad(out, "%rbx");
		out<<"\tcmpq %rbx, %rax\n";
		out<<"\tmovq $0, %rax\n";
		out<<"\tsetg %al\n";
	}
	else if(op == LTE) {
		src1->genLoad(out, "%rax");
		src2->genLoad(out, "%rbx");
		out<<"\tcmpq %rbx, %rax\n";
		out<<"\tmovq $0, %rax\n";
		out<<"\tsetle %al\n";
	}
	else if(op == GTE) {
		src1->genLoad(out, "%rax");
		src2->genLoad(out, "%rbx");
		out<<"\tcmpq %rbx, %rax\n";
		out<<"\tmovq $0, %rax\n";
		out<<"\tsetge %al\n";
	}
	else {
		out << "ERROR: Invalid OP in Binary OP\n";
	}
}

void UnaryOpQuad::codegenX64(std::ostream& out){
	// TODO(Implement me)
	if(op == NEG){
		src->genLoad(out, "%rax");
		out<<"\timulq $-1, %rax\n";
	}
	else if(op == NOT) {
		src->genLoad(out, "%rax");
		// out<<"\tnotq %al\n";
		out <<"\tcmpq $1, %rax\n";
		out <<"\tsetne %al\n";

	}
	else {
		out << "ERROR: Invalid OP in Unary OP\n";
	}
}

void AssignQuad::codegenX64(std::ostream& out){
	src->genLoad(out, "%rax");
	dst->genStore(out, "%rax");
}

void LocQuad::codegenX64(std::ostream& out){
	TODO(Implement me)
}

void JmpQuad::codegenX64(std::ostream& out){
	out << "jmp " << tgt->toString() << "\n";
}

void JmpIfQuad::codegenX64(std::ostream& out){
	// TODO(Implement me)
	cnd->genLoad(out, "%rax");
	out<<"\tcmpq $1, %rax\n";
	if(!invert)
		out<<"\tjne "<<tgt->toString()<<endl;
	else
		out<<"\tje "<<tgt->toString()<<endl;
}

void NopQuad::codegenX64(std::ostream& out){
	out << "nop" << "\n";
}

void SyscallQuad::codegenX64(std::ostream& out){
	// TODO(Implement me)
	// jmpLeave->codegenX64(out);
	if(mySyscall == READ){
		out<<"\tcallq getInt\n";
		myArg->genStore(out,"%rax");
	}
	else if(mySyscall == WRITE){
		// out<<" \tmovq $12, %rdi\n";
		// out<<" \tcallq printInt\n";
		if(myArg->getType() == NUMERIC){
			myArg->genLoad(out,"%rdi");
			out<<"\tcallq printInt\n";
		}
		else{
			myArg->genLoad(out,"%rdi");
			out<<"\tcallq printString\n";
		}

	}
}

void CallQuad::codegenX64(std::ostream& out){
	// TODO(Implement me)
	size_t s = 0;
	out<<"\tcallq fun_"<<callee->getName()<<"\n";
	// cout<<"callee: "<<callee->getTypeString().substr(0,callee->getTypeString().find(">")-1);
	if(callee->getTypeString().substr(0,callee->getTypeString().find(">")-1).length() != 0){
	for(size_t i = 0; i<callee->getTypeString().substr(0,callee->getTypeString().find(">")-1).length(); i++){
		if(callee->getTypeString().substr(0,callee->getTypeString().find(">")-1)[i] == ','){
			s = s + 1;
		}
	}
	s = s + 1;
	out<<"\taddq $"<<s*8<<", %rsp\n";
}

	// if(callee->getTypeString().find("->"));
}

void EnterQuad::codegenX64(std::ostream& out){
	// TODO(Implement me)
		out<<"\tsubq $8, %rsp"<<endl;
		out<<"\tmovq %rbp, (%rsp)\n";
		out<<"\tmovq %rsp, %rbp\n";
		out<<"\taddq $16, %rbp\n";
}

void LeaveQuad::codegenX64(std::ostream& out){
	// TODO(Implement me)
	// out<<" \taddq $8, %rsp"<<endl; // Alocating locals
		out<<"\tmovq (%rsp), %rbp\n";
		out<<"\taddq $8, %rsp\n";
		out<<"\tret\n";
}

void SetInQuad::codegenX64(std::ostream& out){
	// TODO(Implement me)
	opd->genLoad(out,"%rax");
	out<<"\tsubq $8, %rsp\n";
	out<<"\tmovq %rax, (%rsp)";
	out<<"\n";
}

void GetInQuad::codegenX64(std::ostream& out){
	//We don't actually need to do anything here
}

void SetOutQuad::codegenX64(std::ostream& out){
	// TODO(Implement me)
	opd->genLoad(out,"%rax");
}

void GetOutQuad::codegenX64(std::ostream& out){
	// TODO(Implement me)
	// opd->genStore(out,"%rax");
}

void SymOpd::genLoad(std::ostream & out, std::string regStr){
	// TODO(Implement me)
	out<<"\tmovq "<<this->getMemoryLoc()<<", "<<regStr<<endl;
}

void SymOpd::genStore(std::ostream& out, std::string regStr){
	// TODO(Implement me)
	out<<"\tmovq "<<regStr<<", "<<this->getMemoryLoc()<<endl;
}

void AuxOpd::genLoad(std::ostream & out, std::string regStr){
	// TODO(Implement me)
	if(this->getMemoryLoc() != "UNINIT")
	out<<"\tmovq $"<<this->getMemoryLoc()<<", "<<regStr<<endl;
}

void AuxOpd::genStore(std::ostream& out, std::string regStr){
	// TODO(Implement me)
	out<<"\tmovq "<<regStr<<", $"<<this->getMemoryLoc()<<endl;
}

void LitOpd::genLoad(std::ostream & out, std::string regStr){
	// TODO(Implement me)
	// out<<"movq "
	out<<"\tmovq $"<<val<<", "<<regStr<<endl;
}

void LitOpd::genStore(std::ostream& out, std::string regStr){
	throw new InternalError("Cannot use literal as l-val");
}

}
